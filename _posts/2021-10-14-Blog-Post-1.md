---
layout: post
title: Blog Post 1
---

In this post we will learn how to manipulate data and create interactive visualizations of our data.\
We are going to start by importing pandas and numpy.


```python
import pandas as pd
import numpy as np
```

We are going to be working with the NOAA climate data.\
This data is quite large and as such it would be best for us to create a database to access it.\
This will allow us to work with portions of the data as needed instead of having to hold the whole data set.\
Though we could do this without creating a database, it is a useful way of dealing with even larger data sets that you cannot necessarily fit on your computer's RAM.\
Before we start constructing our database,  we're going to learn a bit more about the pandas package.


```python
# We are going to read in our temps.csv file as usual. Except for the added argument
# chunksize. By supplying a value chunksize, the function pd.read_csv() will return
# an iterator instead of a dataframe as we are use to. If n = chunksize then
# each iterand is n rows of temps.csv
df_iter = pd.read_csv("temps.csv", chunksize = 100000)
# For example to access the first n rows of df_iter we do the following
example = df_iter.__next__()
example
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>Year</th>
      <th>VALUE1</th>
      <th>VALUE2</th>
      <th>VALUE3</th>
      <th>VALUE4</th>
      <th>VALUE5</th>
      <th>VALUE6</th>
      <th>VALUE7</th>
      <th>VALUE8</th>
      <th>VALUE9</th>
      <th>VALUE10</th>
      <th>VALUE11</th>
      <th>VALUE12</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>-89.0</td>
      <td>236.0</td>
      <td>472.0</td>
      <td>773.0</td>
      <td>1128.0</td>
      <td>1599.0</td>
      <td>1570.0</td>
      <td>1481.0</td>
      <td>1413.0</td>
      <td>1174.0</td>
      <td>510.0</td>
      <td>-39.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ACW00011604</td>
      <td>1962</td>
      <td>113.0</td>
      <td>85.0</td>
      <td>-154.0</td>
      <td>635.0</td>
      <td>908.0</td>
      <td>1381.0</td>
      <td>1510.0</td>
      <td>1393.0</td>
      <td>1163.0</td>
      <td>994.0</td>
      <td>323.0</td>
      <td>-126.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ACW00011604</td>
      <td>1963</td>
      <td>-713.0</td>
      <td>-553.0</td>
      <td>-99.0</td>
      <td>541.0</td>
      <td>1224.0</td>
      <td>1627.0</td>
      <td>1620.0</td>
      <td>1596.0</td>
      <td>1332.0</td>
      <td>940.0</td>
      <td>566.0</td>
      <td>-108.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ACW00011604</td>
      <td>1964</td>
      <td>62.0</td>
      <td>-85.0</td>
      <td>55.0</td>
      <td>738.0</td>
      <td>1219.0</td>
      <td>1442.0</td>
      <td>1506.0</td>
      <td>1557.0</td>
      <td>1221.0</td>
      <td>788.0</td>
      <td>546.0</td>
      <td>112.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ACW00011604</td>
      <td>1965</td>
      <td>44.0</td>
      <td>-105.0</td>
      <td>38.0</td>
      <td>590.0</td>
      <td>987.0</td>
      <td>1500.0</td>
      <td>1487.0</td>
      <td>1477.0</td>
      <td>1377.0</td>
      <td>974.0</td>
      <td>31.0</td>
      <td>-178.0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>99995</th>
      <td>BR000083361</td>
      <td>1943</td>
      <td>2553.0</td>
      <td>2603.0</td>
      <td>2533.0</td>
      <td>2483.0</td>
      <td>2473.0</td>
      <td>2333.0</td>
      <td>2283.0</td>
      <td>2233.0</td>
      <td>2523.0</td>
      <td>2703.0</td>
      <td>2663.0</td>
      <td>2603.0</td>
    </tr>
    <tr>
      <th>99996</th>
      <td>BR000083361</td>
      <td>1944</td>
      <td>2733.0</td>
      <td>2643.0</td>
      <td>2623.0</td>
      <td>2513.0</td>
      <td>2453.0</td>
      <td>2353.0</td>
      <td>2253.0</td>
      <td>2573.0</td>
      <td>2783.0</td>
      <td>2743.0</td>
      <td>2573.0</td>
      <td>2723.0</td>
    </tr>
    <tr>
      <th>99997</th>
      <td>BR000083361</td>
      <td>1945</td>
      <td>2643.0</td>
      <td>2603.0</td>
      <td>2603.0</td>
      <td>2563.0</td>
      <td>2183.0</td>
      <td>2123.0</td>
      <td>2293.0</td>
      <td>2663.0</td>
      <td>2743.0</td>
      <td>2703.0</td>
      <td>2633.0</td>
      <td>2573.0</td>
    </tr>
    <tr>
      <th>99998</th>
      <td>BR000083361</td>
      <td>1946</td>
      <td>2663.0</td>
      <td>2663.0</td>
      <td>2653.0</td>
      <td>2583.0</td>
      <td>2483.0</td>
      <td>2313.0</td>
      <td>2223.0</td>
      <td>2463.0</td>
      <td>2743.0</td>
      <td>2723.0</td>
      <td>2813.0</td>
      <td>2673.0</td>
    </tr>
    <tr>
      <th>99999</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>2663.0</td>
      <td>2613.0</td>
      <td>2563.0</td>
      <td>2603.0</td>
      <td>2423.0</td>
      <td>2383.0</td>
      <td>2133.0</td>
      <td>2323.0</td>
      <td>2663.0</td>
      <td>2623.0</td>
      <td>2743.0</td>
      <td>2573.0</td>
    </tr>
  </tbody>
</table>
<p>100000 rows Ã— 14 columns</p>
</div>



We're gonna need to reformat this information so that it is easier to use.\
The ID column represents the ID number of a station.\
The Year column is the year of the measurements take.\
The VALUE# columns represnt the temperature measurements a given month (ie VALUE1 being the the temperature measurements for January, VALUE2 for February, etc...)\
The measurements are taken in hundredths of a degree Celsius.\
\
For our purposes, the data would be much easier to use if our temperature measurements were all on a single column. Also, just for convenience, we can rename the VALUE# columns to just the number of the given month.\
Let's run through this process once as an example using the dataframe "example" we created above.


```python
# Let's run the following command overwriting "example" and observe the results
example = example.set_index(keys=["ID","Year"])
```


```python
example
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>VALUE1</th>
      <th>VALUE2</th>
      <th>VALUE3</th>
      <th>VALUE4</th>
      <th>VALUE5</th>
      <th>VALUE6</th>
      <th>VALUE7</th>
      <th>VALUE8</th>
      <th>VALUE9</th>
      <th>VALUE10</th>
      <th>VALUE11</th>
      <th>VALUE12</th>
    </tr>
    <tr>
      <th>ID</th>
      <th>Year</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">ACW00011604</th>
      <th>1961</th>
      <td>-89.0</td>
      <td>236.0</td>
      <td>472.0</td>
      <td>773.0</td>
      <td>1128.0</td>
      <td>1599.0</td>
      <td>1570.0</td>
      <td>1481.0</td>
      <td>1413.0</td>
      <td>1174.0</td>
      <td>510.0</td>
      <td>-39.0</td>
    </tr>
    <tr>
      <th>1962</th>
      <td>113.0</td>
      <td>85.0</td>
      <td>-154.0</td>
      <td>635.0</td>
      <td>908.0</td>
      <td>1381.0</td>
      <td>1510.0</td>
      <td>1393.0</td>
      <td>1163.0</td>
      <td>994.0</td>
      <td>323.0</td>
      <td>-126.0</td>
    </tr>
    <tr>
      <th>1963</th>
      <td>-713.0</td>
      <td>-553.0</td>
      <td>-99.0</td>
      <td>541.0</td>
      <td>1224.0</td>
      <td>1627.0</td>
      <td>1620.0</td>
      <td>1596.0</td>
      <td>1332.0</td>
      <td>940.0</td>
      <td>566.0</td>
      <td>-108.0</td>
    </tr>
    <tr>
      <th>1964</th>
      <td>62.0</td>
      <td>-85.0</td>
      <td>55.0</td>
      <td>738.0</td>
      <td>1219.0</td>
      <td>1442.0</td>
      <td>1506.0</td>
      <td>1557.0</td>
      <td>1221.0</td>
      <td>788.0</td>
      <td>546.0</td>
      <td>112.0</td>
    </tr>
    <tr>
      <th>1965</th>
      <td>44.0</td>
      <td>-105.0</td>
      <td>38.0</td>
      <td>590.0</td>
      <td>987.0</td>
      <td>1500.0</td>
      <td>1487.0</td>
      <td>1477.0</td>
      <td>1377.0</td>
      <td>974.0</td>
      <td>31.0</td>
      <td>-178.0</td>
    </tr>
    <tr>
      <th>...</th>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th rowspan="5" valign="top">BR000083361</th>
      <th>1943</th>
      <td>2553.0</td>
      <td>2603.0</td>
      <td>2533.0</td>
      <td>2483.0</td>
      <td>2473.0</td>
      <td>2333.0</td>
      <td>2283.0</td>
      <td>2233.0</td>
      <td>2523.0</td>
      <td>2703.0</td>
      <td>2663.0</td>
      <td>2603.0</td>
    </tr>
    <tr>
      <th>1944</th>
      <td>2733.0</td>
      <td>2643.0</td>
      <td>2623.0</td>
      <td>2513.0</td>
      <td>2453.0</td>
      <td>2353.0</td>
      <td>2253.0</td>
      <td>2573.0</td>
      <td>2783.0</td>
      <td>2743.0</td>
      <td>2573.0</td>
      <td>2723.0</td>
    </tr>
    <tr>
      <th>1945</th>
      <td>2643.0</td>
      <td>2603.0</td>
      <td>2603.0</td>
      <td>2563.0</td>
      <td>2183.0</td>
      <td>2123.0</td>
      <td>2293.0</td>
      <td>2663.0</td>
      <td>2743.0</td>
      <td>2703.0</td>
      <td>2633.0</td>
      <td>2573.0</td>
    </tr>
    <tr>
      <th>1946</th>
      <td>2663.0</td>
      <td>2663.0</td>
      <td>2653.0</td>
      <td>2583.0</td>
      <td>2483.0</td>
      <td>2313.0</td>
      <td>2223.0</td>
      <td>2463.0</td>
      <td>2743.0</td>
      <td>2723.0</td>
      <td>2813.0</td>
      <td>2673.0</td>
    </tr>
    <tr>
      <th>1947</th>
      <td>2663.0</td>
      <td>2613.0</td>
      <td>2563.0</td>
      <td>2603.0</td>
      <td>2423.0</td>
      <td>2383.0</td>
      <td>2133.0</td>
      <td>2323.0</td>
      <td>2663.0</td>
      <td>2623.0</td>
      <td>2743.0</td>
      <td>2573.0</td>
    </tr>
  </tbody>
</table>
<p>100000 rows Ã— 12 columns</p>
</div>



As you can see, there is now a larger cell that contains the ID of the station instead of repeating the station on every corresponding column. The year column doesn't seem to have changed at first glance. However, if you look closely, what we have done to both the ID and Year columns is we have turned them into multiIndex for our dataframe.\
This is useful as it will allow us to use the pd.stack() function and not change either the "ID" or the "Year" columns.\


```python
# Let's run the following and observe the output
example = example.stack()
```


```python
example
```




    ID           Year         
    ACW00011604  1961  VALUE1      -89.0
                       VALUE2      236.0
                       VALUE3      472.0
                       VALUE4      773.0
                       VALUE5     1128.0
                                   ...  
    BR000083361  1947  VALUE8     2323.0
                       VALUE9     2663.0
                       VALUE10    2623.0
                       VALUE11    2743.0
                       VALUE12    2573.0
    Length: 1032573, dtype: float64



Great! The tempertures are now listed in a single column with the corresponding month in its own column as well. This is almost exactly what we wanted.\
We're almost there, now we want to set "ID" and "Year" to be columns as they were before so we'll need to run the pd.reset_index() function.\


```python
example = example.reset_index()
example
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>Year</th>
      <th>level_2</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>VALUE1</td>
      <td>-89.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>VALUE2</td>
      <td>236.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>VALUE3</td>
      <td>472.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>VALUE4</td>
      <td>773.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>VALUE5</td>
      <td>1128.0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1032568</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>VALUE8</td>
      <td>2323.0</td>
    </tr>
    <tr>
      <th>1032569</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>VALUE9</td>
      <td>2663.0</td>
    </tr>
    <tr>
      <th>1032570</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>VALUE10</td>
      <td>2623.0</td>
    </tr>
    <tr>
      <th>1032571</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>VALUE11</td>
      <td>2743.0</td>
    </tr>
    <tr>
      <th>1032572</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>VALUE12</td>
      <td>2573.0</td>
    </tr>
  </tbody>
</table>
<p>1032573 rows Ã— 4 columns</p>
</div>



Final steps now. We need to rename the last two columns, change the labels of the months from VALUE# to the corresponding number. Then we'll divide the tempertures by 100 to obtain the tempertures in Celcius. We'll aslo add a new column that specifies the date using a neat pandas function!


```python
# rename the last two columns
example = example.rename(columns = {"level_2": "Month", 0 : "Temp"})

# change VALUE# to just #
example["Month"] = example["Month"].str[5:].astype(int)
# re-kajigger the tempertures
example["Temp"] = example["Temp"]/100

# new column for Date, we'll do this in two steps so its easier to follow.
example["Date"] = example["Year"].astype(str)+"-"+example["Month"].astype(str)
example["Date"] = pd.to_datetime(example["Date"])

example
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>Year</th>
      <th>Month</th>
      <th>Temp</th>
      <th>Date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>1</td>
      <td>-0.89</td>
      <td>1961-01-01</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>2</td>
      <td>2.36</td>
      <td>1961-02-01</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>3</td>
      <td>4.72</td>
      <td>1961-03-01</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>4</td>
      <td>7.73</td>
      <td>1961-04-01</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>5</td>
      <td>11.28</td>
      <td>1961-05-01</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1032568</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>8</td>
      <td>23.23</td>
      <td>1947-08-01</td>
    </tr>
    <tr>
      <th>1032569</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>9</td>
      <td>26.63</td>
      <td>1947-09-01</td>
    </tr>
    <tr>
      <th>1032570</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>10</td>
      <td>26.23</td>
      <td>1947-10-01</td>
    </tr>
    <tr>
      <th>1032571</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>11</td>
      <td>27.43</td>
      <td>1947-11-01</td>
    </tr>
    <tr>
      <th>1032572</th>
      <td>BR000083361</td>
      <td>1947</td>
      <td>12</td>
      <td>25.73</td>
      <td>1947-12-01</td>
    </tr>
  </tbody>
</table>
<p>1032573 rows Ã— 5 columns</p>
</div>



Well would you look at that. We got oursleves a dataframe worthy of our non-existant dataframe.\
Now that you understand the process, we're gonna create a function so we can apply this process to all the temps data.


```python
# Let's write the function. Blink and you'll miss it.
def beauty_temps(df):
    '''
    input = df
    This function will transform our temps dataframes as in our example above.
    Temperature will be listed in a single column
    Month will be given as an integer between 1-12
    It also adds a Date column with the date formated as YYYY/MM/DD
    output = df
    '''
    df = df.set_index(keys=["ID","Year"])
    df = df.stack()
    df = df.reset_index()
    df = df.rename(columns = {"level_2": "Month", 0 : "Temp"})
    df["Month"] = df["Month"].str[5:].astype(int)
    df["Temp"] = df["Temp"]/100
    df["Date"] = df["Year"].astype(str)+"-"+df["Month"].astype(str)
    df["Date"] = pd.to_datetime(df["Date"])
    return(df)
```

Our next step is to create our database.\


```python
# To create a database, we will need the sqlite3 package. So let's go ahead and
# import it
import sqlite3
```


```python

# Now we will create a database in the current directory
db = sqlite3.connect("NOAA.db")
# This command will create an empty database in the current directory called
# NOAA.db
```

To add dataframes to our database, we use df.to_sql() function.
We save our temps data to a table called "temperatures" in our database.


```python
# Now we can reformat all the temps.csv data using a simple for loop
# and add the reformated data to our database at the same time
df_iter = pd.read_csv("temps.csv", chunksize = 100000)
for df in df_iter:
    df = beauty_temps(df)
    # the if_exists arguments tells the function what to do if the "temperatures"
    # table is already in our database
    df.to_sql("temperatures", db, if_exists = "append", index = False)
```


```python
# We also need to add the country and station identifiers to our database
stations = pd.read_csv("stations.csv")
# let's quickly change the column names of stations so they are easier to work with

countries = pd.read_csv("countries.csv")
countries = countries.rename(columns = {"FIPS 10-4" : "fips","ISO 3166":"iso"})
stations.to_sql("stations", db, if_exists = "replace", index = False)
countries.to_sql("countries",db , if_exists = "replace",index = False)
# We can now close our connection to the database as we are done constructing it
db.close()
```

Let's take a quick look at how we can interact with and extract information from the database.


```python
# First we open a connection to the database
conn = sqlite3.connect("NOAA.db")
# Next we define a cursor using the conn.cursor() function
cursor = conn.cursor()
# We can check what tables exist on the database
cursor.execute("SELECT name FROM sqlite_master WHERE type = 'table'")
print(cursor.fetchall())
```

    [('temperatures',), ('stations',), ('countries',)]
    

The cursor.execute() function is basically executing SQL commands which is a small programming language specifically used for interacting with databases.\
We're not going to go in depth on this.\
The cursor.fetchall() function returns a list containing all the items returned by the cursor.execute() line above


```python
# we can also inspect the individual columns of the tables in our database
cursor.execute("Select sql FROM sqlite_master WHERE type = 'table';")
for result in cursor.fetchall():
    print(result[0])
```

    CREATE TABLE "temperatures" (
    "ID" TEXT,
      "Year" INTEGER,
      "Month" INTEGER,
      "Temp" REAL,
      "Date" TIMESTAMP
    )
    CREATE TABLE "stations" (
    "ID" TEXT,
      "LATITUDE" REAL,
      "LONGITUDE" REAL,
      "STNELEV" REAL,
      "NAME" TEXT
    )
    CREATE TABLE "countries" (
    "fips" TEXT,
      "iso" TEXT,
      "Name" TEXT
    )
    

Finally, we'll run through a quick example of how to extract specific information from a given table in our database.


```python
# Let's query the database for the FIPS 10-4 of Afganistan
cursor.execute("SELECT fips FROM countries WHERE name = 'Afghanistan'")
result = [cursor.fetchall()]
result
```




    [[('AF',)]]



Note that you can add multiple conditions for the `WHERE` argument using boolean operators `AND` and `OR`.\
Okay, thats the basic stuff. Let's look at something more complex.\
We are going to create a table of all the temperature readings of the month of february from the SAVE station and what year that temperature was from.


```python
# We can split this up and make it more readable
# We can also give aliases for the stations and temperatures tables in our database
cmd = \
"""
Select S.name, T.month, T.temp, T.year
FROM stations S
JOIN temperatures T ON T.id = S.id
WHERE T.month == 2 AND S.name == 'SAVE'
"""
# execute the command
cursor.execute(cmd)
# We'll only look at the first ten rows in the table
result = [cursor.fetchone() for i in range(10)]
result
```




    [('SAVE', 2, 2.36, 1961),
     ('SAVE', 2, 0.85, 1962),
     ('SAVE', 2, -5.53, 1963),
     ('SAVE', 2, -0.85, 1964),
     ('SAVE', 2, -1.05, 1965),
     ('SAVE', 2, -5.61, 1966),
     ('SAVE', 2, 0.89, 1967),
     ('SAVE', 2, -1.3, 1968),
     ('SAVE', 2, -4.41, 1969),
     ('SAVE', 2, -6.51, 1970)]




```python
# Note if we wanted a pandas dataframe of the above we would simply 
# run this instead
df = pd.read_sql_query(cmd, conn)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>Month</th>
      <th>Temp</th>
      <th>Year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>SAVE</td>
      <td>2</td>
      <td>2.36</td>
      <td>1961</td>
    </tr>
    <tr>
      <th>1</th>
      <td>SAVE</td>
      <td>2</td>
      <td>0.85</td>
      <td>1962</td>
    </tr>
    <tr>
      <th>2</th>
      <td>SAVE</td>
      <td>2</td>
      <td>-5.53</td>
      <td>1963</td>
    </tr>
    <tr>
      <th>3</th>
      <td>SAVE</td>
      <td>2</td>
      <td>-0.85</td>
      <td>1964</td>
    </tr>
    <tr>
      <th>4</th>
      <td>SAVE</td>
      <td>2</td>
      <td>-1.05</td>
      <td>1965</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>150</th>
      <td>SAVE</td>
      <td>2</td>
      <td>31.25</td>
      <td>2016</td>
    </tr>
    <tr>
      <th>151</th>
      <td>SAVE</td>
      <td>2</td>
      <td>30.85</td>
      <td>2017</td>
    </tr>
    <tr>
      <th>152</th>
      <td>SAVE</td>
      <td>2</td>
      <td>30.88</td>
      <td>2018</td>
    </tr>
    <tr>
      <th>153</th>
      <td>SAVE</td>
      <td>2</td>
      <td>30.81</td>
      <td>2019</td>
    </tr>
    <tr>
      <th>154</th>
      <td>SAVE</td>
      <td>2</td>
      <td>30.85</td>
      <td>2020</td>
    </tr>
  </tbody>
</table>
<p>155 rows Ã— 4 columns</p>
</div>




```python
# When you're done using the database, close the connection
conn.close()
```

Moving on, we're going to write a function to query our database for specific information.\
The function will take in a set of parameters and output a pandas dataframe. More details in the docstring of the function!


```python
def query_climate_database(country,year_begin=1901,year_end=2020,month=1):
    '''
    Inputs: 
            country: a string giving the name of the country for which data
                    should be returned
            year_begin,year_end: two integers giving the earliest and latest years
                                for which should be returned 
                                (default values: 1901-2020)
            month: an integer from 1-12 giving the month of the year for which should
                   be returned (default value : 1)
    Output:
            df: a pandas dataframe of temerature readings for the specified country,
                in the specified date range, in the specified month of the year.
                The dataframe has 7 columns:
                                            "Name" (the station name)
                                            "Latitude" (of the station)
                                            "Longitude" (of the station)
                                            "Country"
                                            "Year"
                                            "Month"
                                            "Temp"
                                            
    The outputted dataframe will come from querying the NOAA database.
    '''
    # Basic error checking
    if not isinstance(country, str):
        return TypeError("country must be a string")
    if not isinstance(month,int):
        return TypeError("month must be an integer between 1 and 12")
    if month<1 or month > 12:
        return ValueError("month must be an integer between 1 and 12")
    if not isinstance(year_begin,int) or not isinstance(year_end,int):
        return TypeError("Both year_begin and year_end must be integers")
    if year_begin > year_end:
        return ValueError("year_end must be later than year_begin")
    if year_begin < 1901 or year_end < 1901 or year_end > 2020 or year_begin > 2020:
            return ValueError("""year_end and year_begin must 
                              both be between 1901 and 2020""")
    # we start by opening a connection to our constructed database
    conn = sqlite3.connect("NOAA.db")
    # cursor is our primary method of interacting with the database
    # it helps execute SQL commands.
    cursor = conn.cursor()
    # Here we are using a few new methods
    # First, notice the substr(), this behaves the same as the .str[] method
    # Additionally, we are using the BETWEEN method which allows to check if
    # T.year is between the two specified years
    cmd = \
    """
    SELECT S.name, S.latitude, S.longitude, C.name, 
    T.year, T.month, T.temp
    FROM stations S
    JOIN temperatures T ON T.id == S.id
    JOIN countries C ON C.name = :cntry
    WHERE substr(T.id,0,3) = C.fips 
    AND T.month = :mth AND T.year BETWEEN :start AND :end
    """
    # We are also using :variable (eg :cntry) in our cmd text
    # what this does is it allows us to substitute parameters so
    # we can specify dynamic values in our command
    # we'll need a dictionary so that our query knows what to put as
    # arguments.
    # this way of doing it is called the name style
    # it is also more secure method of querying our database
    key = {"cntry":country,"mth":month,"start":year_begin,"end":year_end}
    try: 
        # This line constructs our dataframe
        df = pd.read_sql_query(cmd,conn,params = key)
    except ValueError:
        # if the above line could not run then we close our connection
        # and throw a ValueError
        conn.close()
        print("You have entered an invalid country name.")
    # we'll return the dataframe but not before closing our connection!
    conn.close()
    df = df.rename(columns={"Name":"Country"})
    return(df)
```


```python
# Here is an example of our function.
df = query_climate_database(country = "Myanmar", 
                       year_begin = 1950, 
                       year_end = 2020,
                       month = 1)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>Country</th>
      <th>Year</th>
      <th>Month</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>MYITKYINA</td>
      <td>25.367</td>
      <td>97.4</td>
      <td>Myanmar</td>
      <td>1961</td>
      <td>1</td>
      <td>17.09</td>
    </tr>
    <tr>
      <th>1</th>
      <td>MYITKYINA</td>
      <td>25.367</td>
      <td>97.4</td>
      <td>Myanmar</td>
      <td>1962</td>
      <td>1</td>
      <td>15.79</td>
    </tr>
    <tr>
      <th>2</th>
      <td>MYITKYINA</td>
      <td>25.367</td>
      <td>97.4</td>
      <td>Myanmar</td>
      <td>1963</td>
      <td>1</td>
      <td>15.99</td>
    </tr>
    <tr>
      <th>3</th>
      <td>MYITKYINA</td>
      <td>25.367</td>
      <td>97.4</td>
      <td>Myanmar</td>
      <td>1964</td>
      <td>1</td>
      <td>16.59</td>
    </tr>
    <tr>
      <th>4</th>
      <td>MYITKYINA</td>
      <td>25.367</td>
      <td>97.4</td>
      <td>Myanmar</td>
      <td>1965</td>
      <td>1</td>
      <td>16.49</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>358</th>
      <td>RANGOON</td>
      <td>16.770</td>
      <td>96.2</td>
      <td>Myanmar</td>
      <td>1992</td>
      <td>1</td>
      <td>23.80</td>
    </tr>
    <tr>
      <th>359</th>
      <td>RANGOON</td>
      <td>16.770</td>
      <td>96.2</td>
      <td>Myanmar</td>
      <td>1993</td>
      <td>1</td>
      <td>23.60</td>
    </tr>
    <tr>
      <th>360</th>
      <td>RANGOON</td>
      <td>16.770</td>
      <td>96.2</td>
      <td>Myanmar</td>
      <td>1995</td>
      <td>1</td>
      <td>25.20</td>
    </tr>
    <tr>
      <th>361</th>
      <td>RANGOON</td>
      <td>16.770</td>
      <td>96.2</td>
      <td>Myanmar</td>
      <td>1996</td>
      <td>1</td>
      <td>27.30</td>
    </tr>
    <tr>
      <th>362</th>
      <td>RANGOON</td>
      <td>16.770</td>
      <td>96.2</td>
      <td>Myanmar</td>
      <td>2005</td>
      <td>1</td>
      <td>24.10</td>
    </tr>
  </tbody>
</table>
<p>363 rows Ã— 7 columns</p>
</div>



Next we are going to create an interactive visualization of the average yearly change in temperature of a given country.\
To do this we will need a few packages.\
We'll need LinearRegression from sklearn.linear_model.\
datetime just for convenience.\
And finally, a new package express from plotly express!\


```python
# To start we are going to define a little function that will use linear regression
# This function is just gonna be a helper function to get the average yearly change in
# temperature.
# We're also just gonna import datetime though we won't use it until later
# alternatively, you could just make a dictionary that relates integers 1-12 to
# the corresponding month and not use the datetime package.
from sklearn.linear_model import LinearRegression
import datetime

def coef(data_group):
    '''
    Input: a dataframe contructed by the query_climate_database function
    Output: the average yearly temperature change at every given station
    '''
    x = data_group[["Year"]] 
    y = data_group["Temp"]
    LR = LinearRegression()
    LR.fit(x, y)
    return np.round(LR.coef_[0],3)
```

I hope you've got the plotly package installed because we are going to import express now.


```python
from plotly import express as px
```

Lets define a function to create the visualizations we are looking for.\
I'll walk you through it just read it carefully. If you get lost then just follow the ABC principle.\
A-Always\
B-Be\
C-Rereading


```python
def temperature_coefficient_plot(country,year_begin=1901,year_end = 2020,
                                 month=1,min_obs=10,
                                 mapbox_style = "carto-darkmatter",
                                 color_continuous_midpoint = 0,
                                 color_continuous_scale = "purd",
                                 **kwargs):
    '''
    Inputs: 
            country: a string of the name of the country which we want will create
            a visualization of average yearly temperature change
            year_begin,year_end: two integers giving the earliest and latest years
                                 which we will use for our data
                                (default values: 1901-2020)
            month: an integer between 1-12 of the month we are interested in
            mapbox_style: the map layout style (default = "carto-darkmatter")
            color_continuous_midpoint: the midpoint of our color bar (default = 0)
            color_continuous_scale: the color scale used to portray the average
                                    temperature changes
            **kwargs: other arguments for the px.scatter_mapbox() function
    Output:
            fig: a map built using the scatter_mapbox from plotly express
                each point on the map will represent a station in the country
                of interest. The color of the point will be chosen by the average
                yearly temperature change recorded at that station.
                The figure will also have an appropriate title and a color bar.
    '''
    # Error checking min_obs input
    if not isinstance(min_obs,int):
        raise TypeError("min_obs must be an int")
    
    # We will contruct a dataframe using our previous function.
    df = query_climate_database(country,year_begin,year_end,month)
    
    # If there are no stations in the country that was chosen then
    # a ValueError is raised to inform the user.
    if len(df) == 0:
        raise ValueError("There are no stations in "+country+"."
                        " Please select a different country")
        
        
    # So, now we are going to sort our dataframe by the name of the station using
    # the pd.groupby() function.
    # the transform function is going to produce a dataframe of equal length to df
    # using the np.count_nonzero() function, we are going to count how many
    # readings we have from each station.
    # So, .transform() will be a dataframe with one column that will correspond
    # to the number of readings a station has
    # we'll save this to the a new column in df and call the column "count"
    df["count"] = df.groupby(["NAME"])["NAME"].transform(np.count_nonzero)
    # this allows us to simply ommit any station that does not have enough readings
    # to satisfy min_obs as such
    df = df[df["count"] > min_obs - 1]
    
    # If there are no stations with enough readings, then we raise a ValueError
    # to inform the user
    if len(df) == 0:
        raise ValueError("There are not enough observations at any station to "
                        "statisfy the chosen value for min_obs.")
    
    # Okay now we use the .apply() method and our coef function from before
    # we'll create a new data frame with 4 columns
    # Name, Latitude, Longitude and the average yearly temperature change as
    # calculated by the coef function
    coeff = df.groupby(["NAME","LATITUDE","LONGITUDE"]).apply(coef)
    # reset the index so that the average yearly temperature change
    # is an actual column
    coeff = coeff.reset_index()
    # rename the column to something appropriate
    coeff = coeff.rename(columns = {0:"Estimated Yearly<br> Increase (Â°C)"})
    
    # Change the int month to the corresponding name of the month
    month = datetime.date(1,month,1).strftime('%B')
    
    # Create an approriate title for our plot.
    plot_title = ('Estimates of yearly increase in temperature in {m}<br>' 
    'for stations in {c}, years {begin}-{end}'.format(
                    m = month,
                    c = country,
                    begin = year_begin,
                    end = year_end
                    ))
    # Now we create the figure, it can take our dataframe coeff and read the columns
    # it is a map and so we will specify the latitude and longitude of the station
    # we want the user to be able to hover over a point and see the name of the
    # station
    # we specify that color is decided by the average yearly increase in temperature
    # add the title
    # then other details for the map style, the colorbar center and any inputs 
    # that the user wants that are valid.
    # If the function does not run then we raise a value error explaining to the
    # user what probably went wrong.
    try:
        fig = px.scatter_mapbox(coeff,
                            lat = "LATITUDE",
                            lon = "LONGITUDE",
                            hover_name = "NAME",
                            color = "Estimated Yearly<br> Increase (Â°C)",
                            title = plot_title,
                            mapbox_style = mapbox_style,
                            color_continuous_scale = color_continuous_scale,
                            color_continuous_midpoint = color_continuous_midpoint,
                            **kwargs)
        fig.update_layout(margin={"r":0,"t":55,"l":0,"b":0})
    except ValueError:
        print("Invalid input for mapbox_style,"
             "color_continuous_scale,"
             "color_continuous_midpoint,"
             "or **kwargs.")
    
    
    
    
    # finally we return the figure
    return(fig)
```


```python
# Here's an example of our function 
fig = temperature_coefficient_plot("Peru", 1950, 2020, 6, 
                                   min_obs = 4,
                                   zoom = 4)
# to show the figure, we have to run fig.show()
fig.show()
```
{% include BP1_1.html %}

Let's now make a different figure.\
We're interested in answering the following question:\
Can we detect an increase in maximum, minimum or median temperatures over the years in a country and is there any correlations we can spot just by looking at the data?


```python
# A slight variation of our first query function.
def query_climate_database_2(country,year_begin=1901,year_end=2020,month=1):
    '''
    Inputs: 
            country: a string giving the name of the country for which data
                    should be returned
            year_begin,year_end: two integers giving the earliest and latest years
                                for which should be returned 
                                (default values: 1901-2020)
            month: an integer from 1-12 giving the month of the year for which should
                   be returned (default value : 1)
    Output:
            df: a pandas dataframe of temerature readings for the specified country,
                in the specified date range, in the specified month of the year.
                The dataframe has 4 columns:
                                            "Country"
                                            "Year"
                                            "Month"
                                            "Temp"
                                            
    The outputted dataframe will come from querying the NOAA database.
    '''
    # Basic error checking
    if not isinstance(country, str):
        return TypeError("country must be a string")
    if not isinstance(month,int):
        return TypeError("month must be an integer between 1 and 12")
    if month<1 or month > 12:
        return ValueError("month must be an integer between 1 and 12")
    if not isinstance(year_begin,int) or not isinstance(year_end,int):
        return TypeError("Both year_begin and year_end must be integers")
    if year_begin > year_end:
        return ValueError("year_end must be later than year_begin")
    if year_begin < 1901 or year_end < 1901 or year_end > 2020 or year_begin > 2020:
            return ValueError("""year_end and year_begin must 
                              both be between 1901 and 2020""")
    # we start by opening a connection to our constructed database
    conn = sqlite3.connect("NOAA.db")
    cursor = conn.cursor()
    # Only change is we no longer need the station data so we won't query for it
    cmd = \
    """
    SELECT C.name, T.year, T.month, T.temp
    FROM temperatures T
    JOIN countries C ON C.name = :cntry
    WHERE substr(T.id,0,3) = C.fips 
    AND T.month = :mth AND T.year BETWEEN :start AND :end
    """
    key = {"cntry":country,"mth":month,"start":year_begin,"end":year_end}
    try: 
        # This line constructs our dataframe
        df = pd.read_sql_query(cmd,conn,params = key)
    except ValueError:
        # if the above line could not run then we close our connection
        # and throw a ValueError
        conn.close()
        print("You have entered an invalid country name.")
    # we'll return the dataframe but not before closing our connection!
    conn.close()
    df = df.rename(columns={"Name":"Country"})
    return(df)
```


```python
# To visualize this, we are going to use a matrix of scatter plots.

def matrix_splot(country,year_begin=1901,year_end = 2020,
                                 month=1,
                                 **kwargs):
    '''
    Inputs: 
            country: a string of the name of the country which we want will create
            a visualization of average yearly temperature change
            year_begin,year_end: two integers giving the earliest and latest years
                                 which we will use for our data
                                (default values: 1901-2020)
            month: an integer between 1-12 of the month we are interested in
            **kwargs: other arguments for the px.matrix_scatter() function
    Output:
            fig: a matrix of scatter plots to visualize the median, minimum and
            maximum temperature of a given country on a given
            month within a range of years.
    '''
    
    # We will contruct a dataframe using our second querying function
    df = query_climate_database_2(country,year_begin,year_end,month)
    
    # If there are no temperature readings in the country that was chosen then
    # a ValueError is raised to inform the user.
    if len(df) == 0:
        raise ValueError("There are no stations in "+country+"."
                        " Please select a different country")
    # adding the needed data to our dataframe using the transform method and
    # varyious numpy functions
    df["Median Temp (Â°C)"] = df.groupby(["Year"])["Temp"].transform(np.median)
    df["Min Temp (Â°C)"] = df.groupby(["Year"])["Temp"].transform(np.min)
    df["Max Temp (Â°C)"] = df.groupby(["Year"])["Temp"].transform(np.max)
    
    # Change the int month to the corresponding name of the month
    month = datetime.date(1,month,1).strftime('%B')
    
    # Create an approriate title for our plot.
    plot_title = ('Matrix of scatter plots for temperature data during the month of'
                  ' {m}<br>in {c}, years {begin}-{end}'.format(
                    m = month,
                    c = country,
                    begin = year_begin,
                    end = year_end
                    ))
    # We use the px.scatter_matrix() function to create the desired figure
    # If there is an issue building the plot then we notify the user
    try:
        fig = px.scatter_matrix(df,
                                dimensions = ["Min Temp (Â°C)",
                                              "Median Temp (Â°C)",
                                              "Max Temp (Â°C)"],
                                color = "Year",
                                title = plot_title,
                                **kwargs)
        fig.update_layout(margin={"r":50,"t":55,"l":0,"b":20})
    except ValueError:
        print("Invalid input for **kwargs.")
        
    # finally we return the figure
    return(fig)
```


```python
# Here is an example of our scatter plot matrix function
fig = matrix_splot("Iceland",1985,2010,5)
fig.show()
```
{% include BP1_2.html %}

Let's try something else.


How do the twenty year average temperatures from 1940-2020 of a given country differ from the average temperature of the 20th century?\
For this we're going to look at each month of the year seperately and compute averages based on the month.


```python
## Slight variation in our database query again

def query_climate_database_3(country):
    '''
    Inputs: 
            country: a string giving the name of the country for which data
                    should be returned
    Output:
            df: a pandas dataframe of temerature readings for the specified country,
                in the specified date range, in the specified month of the year.
                The dataframe has 4 columns:
                                            "Station"
                                            "Year"
                                            "Month"
                                            "Temp"
                                            
    The outputted dataframe will come from querying the NOAA database.
    '''
    # Basic error checking
    if not isinstance(country, str):
        return TypeError("country must be a string")
    
    # we start by opening a connection to our constructed database
    conn = sqlite3.connect("NOAA.db")
    cursor = conn.cursor()
    # Some changes to our query string
    cmd = \
    """
    SELECT T.year, T.month, T.temp
    FROM temperatures T
    JOIN countries C ON C.name == :cntry
    WHERE substr(T.id,0,3) == C.fips
    AND T.year BETWEEN 1901 AND 2020
    """
    key = {"cntry" : country}
    try: 
        # This line constructs our dataframe
        df = pd.read_sql_query(cmd,conn,params = key)
    except ValueError:
        # if the above line could not run then we close our connection
        # and throw a ValueError
        conn.close()
        print("You have entered an invalid country name.")
    # we'll return the dataframe but not before closing our connection!
    conn.close()
    df = df.rename(columns={"NAME":"Station"})
    return(df)
```


```python
# This is a small helper function to help us contruct a dataframe that would be
# easy to graph
def further_beyond(data,twenty):
    '''
    Inputs:
            data: a data frame constructed by query_climate_database_3()
    
            twenty: a database of the monthly average temperature of the 
            twentieth century for the given country.
    Output:
            out: a dataframe with 4 columns:
                                    "Years": The years that the averages were taken
                                    "Month": The month
                                    "Temp": The average temperature of those years
                                    "Difference (Â°C) from 20th century average":
                                    The difference between the 20 year average and the
                                    20th century average
    '''
    # first we extrace the data from the years 1920-1940
    out = data[data["Year"].between(1920,1940)]
    # then we take the mean temperature of each month in that time period
    out = out.groupby(["Month"])["Temp"].apply(np.mean)
    # reset index
    out = out.reset_index()
    # Populate a column to indicate the date range of the average temperature
    out["Years"] = "1920-1940"
    # Take the difference of the 20 year average and the 20th century averages
    out["Difference (Â°C) from 20th century average"] = out["Temp"]-twenty["Temp"]
    # for loop to construct the rest of the data as we did above
    for i in range(4):
        helper = 20*i
        avrg = data[data["Year"].between(1940+helper,1960+helper)]
        avrg = avrg.groupby(["Month"])["Temp"].apply(np.mean)
        avrg = avrg.reset_index()
        avrg["Years"] = str(1920+helper)+"-"+str(1940+helper)
        avrg["Difference (Â°C) from 20th century average"] = avrg["Temp"]-twenty["Temp"]
        # append the dataframes to each other. 
        out = out.append(avrg)
    # return the completed dataframe
    return(out)
```


```python
def twenty1_year_average_fig(country,**kwargs):
    '''
    Inputs: 
            country: a string of the name of the country which we want will create
            a visualization of average yearly temperature change
    Output:
            fig: a scatterplot built by px.scatter() that maps the difference
            between monthly twenty year average temperatures from 1920 to 2020
            and the twentieth century average monthly temperature of the given country
    '''
    # start by querying to build our dataframe
    df = query_climate_database_3(country)
    # compute the average temperature of the 20th century by month
    if len(df) == 0:
        raise ValueError("There are no readings in "+country+"."
                        " Please select a different country")
    twentieth_avg = df[df["Year"]<2000]
    twentieth_avg = twentieth_avg.groupby(["Month"])["Temp"].apply(np.mean)
    twentieth_avg = twentieth_avg.reset_index()
    # define a dictionary for the colors of the figure
    color_dict = {"1920-1940":"pink",
                  "1940-1960": "orange",
                  "1960-1980": "darkgreen",
                  "1980-2000": "purple",
                  "2000-2020": "red"
                 }
    Title = """Change in termperature between the 20 year average monthly
    temperature from 1920-2020<br> for :cnt, <br>
    and the average monthly temperature of the 20th century
    """
    # Use helper function to build the necessary dataframe from df
    FINAL_FORM = further_beyond(df,twentieth_avg)
    # Change the "Month" column from integers to the names of the months
    FINAL_FORM["Month"] = pd.to_datetime(FINAL_FORM['Month'], format='%m').dt.month_name()
    
    # make the figure 
    fig = px.scatter(FINAL_FORM, x = "Month",
                     y="Difference (Â°C) from 20th century average",
                     color = "Years",
                     width =800,height = 600,
                     color_discrete_map = color_dict,**kwargs)
    # add a doted line that represents the twentieth century average
    fig.add_hline(y=0,line_dash = 'dot')
    return(fig)
```


```python
fig = twenty1_year_average_fig("India")
fig.show()
```
{% include BP1_3.html %}

